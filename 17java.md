0、已知一棵二叉树的先序和中序遍历序列如下：先序：A、B、C、D、E、F、G、H、I，J中序：C、B、A、E、F、D、I、H、J、G其后序遍历序列为：
C、B、F、E、I、J、H、G、D、A
先序遍历：根、先序左子树、先序右子树
中序遍历：中序左子树、根、中序右子树
后序遍历：后序左子树、后序右子树、根

先序遍历：第一个是根
中序遍历：根把序列分为左右两支
后序遍历：最后一个是根


9、在TCP/IP建立连接过程中，客户端或服务器的状态转移说法错误的是？

    TIME_WAIT是断开连接时的状态（属于第四次握手）
经历SYN_RECV状态经历SYN_SEND状态经历ESTABLISHED状态服务器在收到syn包时将加入半连接队列服务器收到客户端的ack包后将从半连接队列删除

8、已知IBM的PowerPC是big-endian字节序列而Intel的X86是little-endian字节序，如果在地址啊存储的整形值时0x04030201，那么地址为a+3的字节内存储的值在PowerPC和Intel X86结构下的值分别是？()

整型四个字节，每两位一个字节存储

big-endian 大端：从大地址开始存储，按照数字从右往左，高位在低地址

little-endian 小端：从小地址开始存储，按照数字从右往左，低位在低地址
a+3即从数字的低位开始（从右往左）加三个字节
大端从大地址开始存储，小端相反，两者都是从数据低位开始存起；
假设从上至下地址递增，则
PowerPC（大）：                    Intel X86（小）：
04                                            01                    低
03                                            02                      |
02                                            03                      |  
01                                            04                     高
a+3指向最大的地址，所以分别为1       4


6、以下哪种方式，在读取磁盘上多个顺序数据块时的效率最高？

程序直接访问方式（循环检查I/O方式：）：最古老的方式。CPU和IO串行，每读一个字节（或字），CPU都需要不断检测状态寄存器的busy标志，当busy=1时，表示IO还没完成；当busy=0时，表示IO完成。此时读取一个字的过程才结束，接着读取下一个字（以字节为单位）

中断控制方式：循环检测先进些，IO设备和CPU可以并行工作，只有在开始IO和结束IO时，才需要CPU。但每次只能读取一个字

DMA方式：直接存储器访问，比中断先进的地方是每次可以读取一个块，而不是一个字（以一个连续的数据块为单位）

通道方式：比DMA先进的地方是，每次可以处理多个块，而不只是一个块（以一组数据块为单位）
     通道方式>DMA方式>中断控制方式>程序直接访问方式(循环检测IO方式)
     
     
     5、工程师M发明了一种游戏：M将一个小球随机放入完全相同的三个盒子中的某一个，玩家选中装有球的盒子即获胜；开始时M会让玩家选择一个盒子（选择任何一个获胜概率均为1/3）;玩家做出选择后，M会打开没有被选择的两个盒子中的一个空盒，此时M会询问玩家是否更改选择（可以坚持第一次选择，也可以选择另一个没有打开的盒子），下列叙述正确的有（）



三个盒子A，B，C。其中，1表示有球，0表示没球。

选取三个盒子概率都一样。我们假设选择了A。
此时有三种情况如下所示：
 
情况一：我选中了有球的盒子，我更换的话将失败，不更换的话将成功。
情况二：我选中了没球的盒子，我更换的话将成功，不更换的话将失败。
情况三：我选中了没球的盒子，我更换的话将成功，不更换的话将失败。
综上，我们发现更换了成功的概率是2/3；二不更换成功的概率是1/3。
所以  选择另一个没有被打开的盒子获胜概率更高

结构体字节对齐规则
先介绍三个概念：自身对齐值、指定对齐值、有效对齐值。

自身对齐值：数据类型本身的对齐值，例如char类型的自身对齐值是1，short类型是2；
指定对齐值：编译器或程序员指定的对齐值，32位单片机的指定对齐值默认是4；#pragma pack(2)
有效对齐值：自身对齐值和指定对齐值中较小的那个。

对齐有两个规则：
1、不但结构体的成员有有效对齐值，结构体本身也有对齐值，这主要是考虑结构体的数组，对于结构体或者类，要将其补齐为其有效对齐值的整数倍。结构体的有效对齐值是其最大数据成员的自身对齐值；
2、存放成员的起始地址必须是该成员有效对齐值的整数倍。


12、问题描述     sizeof(bu)的值是(  22   ) 

#pragma pack(2)
class BU
{
    int number;
    union UBffer
    {
        char buffer[13];
        int number;
    }ubuf;
    void foo(){}
    typedef char*(*f)(void*);
    enum{hdd,ssd,blueray}disk;
}bu;
union:当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)；
它有以下特点：
    （1）它是一个结构；
    （2）它的所有成员相对于基地址的偏移量都为0；
    （3）此结构空间要大到足够容纳最"宽"的成员；
    （4）其对齐方式要适合其中所有的成员
综上：
而分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。
    本题目中
    注意第一行，#pragma pack(2)
    首先考虑没有这句话时，我们在类、结构或者union补齐字节的时候，找它们的成员数据中找字节最大的那个数去衡量如何对     齐，假设为z；
    但是有了这句话以后，对齐方式是取 pack(n)中n和z的最小值去对齐；
    可见本题中对齐字节数为2；
    之后往下看 int number; 占4个字节
    接下来考虑union大小
    union UBffer
    {
        char buffer[13]; // 13
        int number; // 4
    }bu; 
   buffer 是13个字节，number 是4个字节，取最大的 为13，注意还要字节对齐，对齐字节数为2，所以Union大小为14，既满   足buffer的对齐 也满足number的对齐。
    void foo(){}：空函数不占取字节
     typedef  char*(*f)  (void*); 未实例化指针不占取字节
     enum只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做int来存储的，所以枚举类型的sizeof值都为4
14+4+4+0+0=22；


13、同一个进程中的线程不共享的部分是(栈空间)

       线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。
进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：
1.线程ID
      每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。
2.寄存器组的值
      由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
3.线程的堆栈
      堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是 thread safe 的。
4.错误返回码
      由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。
5.线程的信号屏蔽码
       由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。
6.线程的优先级
       由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。


VLAN（Virtual Local Area Network）的中文名为"虚拟局域网"。
虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。VLAN是一种比较新的技术，工作在OSI参考模型的第2层和第3层，一个VLAN就是一个广播域，VLAN之间的通信是通过第3层的路由器来完成的。与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播活动；可提高网络的安全性。
在计算机网络中，一个二层网络可以被划分为多个不同的广播域，一个广播域对应了一个特定的用户组，默认情况下这些不同的广播域是相互隔离的。不同的广播域之间想要通信，需要通过一个或多个路由器。这样的一个广播域就称为VLAN


17、刚毕业的小王上班有两路公交车都可以从家到公司.如果只等A车,平均需要5分钟才等到;如果只等B车,平均需要7分钟才能等到.假定两辆车运行时间独立,那么小王平均需要等多长时间才能等到A车或B车?(  2.55   )

时间段t内A车 t/5趟，B车 t/7趟，所以在t内等到车共计t/5+t/7趟，等到一趟的时间则为t/(t/5+t/7)，等价35/12

18、一个黑色袋子中装有5个红球，5个蓝球，5个黄球，从中抽取三次，每次抽一个球，取完不放回，则每种颜色球各得一个的概率是（）

5/15 * 5/14 *5/13=25/91



int* pint = 0; 
pint += 6; 
cout << pint << endl;

两个点：
1.在初始化中只有地址才能赋值给指针，因此*int p=0是指p指向地址0x00。
2.int型数占4个字节，因此加6表示偏移了24个字节，结果的地址应为0x18，即是24.


ARP和RARP 是网络层的协议，但是它所工作的内容是链路层的。。。具体来说应该是在网络层。
地址解析协议（Address Resolution Protocol，ARP）是在仅知道主机的IP地址时确定其物理地址的一种协议。因IPv4和以太网的广泛应用，其主要用作将IP地址翻译为以太网的MAC地址，但其也能在ATM和FDDIIP网络中使用。从IP地址到物理地址的映射有两种方式：表格方式和非表格方式。ARP具体说来就是将网络层（IP层，也就是相当于OSI的第三层）地址解析为数据连接层（MAC层，也就是相当于OSI的第二层）的MAC地址。

ICMP是网络层，UDP是传输层，FTP和HTTP是应用层 目前VPN隧道协议主要有4种：点到点隧道协议PPTP、第二层隧道协议L2TP、网络层隧道协议IPSec以及SOCKS v5协议。其中，PPTP和L2TP工作在数据链路层，IPSec工作在网络层，SOCK v5工作在会话层。



大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  

小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]
构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。
此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。
https://www.cnblogs.com/chengxiao/p/6129630.html


甲乙丙三人是阿里巴巴开发人员，ABC三人是阿里巴巴测试人员，每个开发都有对应的测试人员。主管介绍说：“A对应的开发是乙的好友，并在三个开发中最年轻；丙的年龄比C对应的开发大。”则开发和测试的对应关系为（甲-A，乙-C，丙-B


24、某机器人可以说真话或者假话。某程序设定其周末（周六周日）说真话，周四说谎话，其他日期随机。某测试打算验证该功能。他连续七天，每天问机器人“你在哪里出生的？”，在前六天得到了这样的答案：阿里，淘宝，阿里，淘宝，天猫，淘宝。那么第七天，机器人的回答应该是）
周六周日说真话，所以有连续两天的答案是一样的所以只有第一天是周日才可能有这种情况，顾答案是阿里

IP数据报头采用（）字节序，在此字节序下从低地址到高地址0x1234的表示形式为 （C） 
 big_endian,0x12 0x34 0 0
 little_endian,0x34 0x12 0 0
 big_endian,0 0 0x12 0x34
 little_endian, 0 0 0x34 0x12
